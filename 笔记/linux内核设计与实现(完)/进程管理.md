<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

   - [进程管理](#进程管理)   
      - [进程](#进程)   
      - [进程描述符及任务结构](#进程描述符及任务结构)   
      - [进程创建](#进程创建)   
      - [线程在Linux中的实现](#线程在linux中的实现)   
      - [进程终结](#进程终结)   

<!-- /MDTOC -->

## 进程管理
### 进程
1.进程是处于执行期程序以及相关资源的总称

2.Linux内核调度的对象是线程，Linux并不特别区分线程和进程

3.现代操作系统，进程提供两种虚拟机制
* 虚拟处理器，它让进程以为自己在独享处理器
* 虚拟内存，它让进程以为自己拥有所有内存资源

4.在Linux中，使用fork来创建进程，fork完之后，通过exec函数创建新的地址空间，并把新的程序载入其中，Linux的fork是由clone系统调用实现的

5.通过exit系统调用推出执行进程，退出后进入僵死状态，直到父进程调用wait/waitpid为止

### 进程描述符及任务结构
1.进程描述符中包含的数据能完整地描述一个正在执行的进程。具体类型是task_struct

2.任务队列是一个双向循环链表，每一项都是task_struct

3.Linux通过slab分配器分配进程描述，这样能达到对象复用和缓存着色的目的

4.在线程的thread_info结构中保存有一个指向进程描述符的指针

5.进程的唯一表示是PID，存放在进程描述符中

6.进程描述符的state记录了进程的状态，进程只有五种状态
   * 运行 可执行/正在执行/在运行队列中待执行，进程在用户空间唯一状态，内核空间也有这种状态
   * 可中断 正在被阻塞，等待条件达成
   * 不可中断 接收到信号也不会解除阻塞，使用的很少
   * 被其他进程跟踪 被其他进程跟踪
   * 停止 停止了

7.进程家族树
* 所有的进程都是PID为1的init进程后代
* 每个进程都有父进程
* 在进程描述符中，有一个指向其父进程的进程描述符指针，以及子进程进程描述符指针的链表

### 进程创建
1.Linux创建进程分为两步
* fork 拷贝当前进程创建一个子进程
* exec读取可执行文件并载入地址空间开始运行

2.进程的地址空间常常包含有数十M的数据，我们fork的时候，不需要先拷贝这些数据，因为子进程fork后一般会直接调用exec运行一个可执行文件，这种写时拷贝可以优化效率

3.Linux通过clone系统调用实现fork，clone实际调用的do_fork，do_fork完成创建大部分工作，然后调用copy_process来让进程开始执行，copy_process做下面的工作:
* 为进程创建一个新的内核栈，thread_info，进程描述符，此时子进程和父进程进程描述符完全一样
* 检查进程数没有超过限制
* 子进程将进程描述符的一部分信息初始化成新的
* 子进程设置成不可中断态
* 分配一个PID
* 复制共享进程的的各个部分
* 返回一个指向子进程的指针
* 返回到do_fork函数，do_fork执行完成后，进程处于可运行态，但是啥时候运行就得看调度了

4.vfork创建的子进程共享父进程的内存(不拷贝页表项)， 直至其成功执行了exec()或者调用_exit()退出，现在fork有了写时拷贝，所以vfork意义不大了

### 线程在Linux中的实现
1.Linux并不区分线程和进程，线程都有自己的task_struct(进程描述符)，只是和其他进程共享了一些资源

2.假设我们有一个进程包含四个线程，那么Linux就创建四个进程并创建四个进程描述符，同时制定它们共享某些资源

3.线程创建于进程类似，只是要传递一些参数要指明需要贡献的资源

4.内核线程是独立运行在内核空间的标准进程，只在内核空间运行，没有独立的地址空间，可以被调度和抢占

### 进程终结
1.当一个进程终结时，内核必须释放它的资源，并通知其父进程

2.进程析构是进程进行exit系统调用时，或者进程接收到一个不能处理，也不能忽略的信号或异常时

3.进程析构工作主要是靠do_exit来完成，它会释放归还资源给系统

5.调用do_exit后，进程处于僵死状态，但是系统还保留有进程描述符，这时子进程会想父进程发送SIGCHLD信号，父进程捕获后通过wait系统调用来获取子进程退出信息，这时子进程的进程描述符被释放

6.如果父进程在子进程之前退出，子进程必须在退出时要找到新的父亲，否则它就永远都是僵死进程，这时，子进程在当前进程组内找一个进程作为父亲，一直到init进程
