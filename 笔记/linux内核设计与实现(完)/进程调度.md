<!-- MDTOC maxdepth:6 firsth1:2 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

   - [多任务](#多任务)   
   - [针对普通进程的-完全公平调度算法CFS](#针对普通进程的-完全公平调度算法cfs)   
   - [抢占](#抢占)   
      - [用户抢占](#用户抢占)   
      - [内核抢占](#内核抢占)   
   - [实时进程的调度策略](#实时进程的调度策略)   
   - [与优先级相关的系统调用](#与优先级相关的系统调用)   

<!-- /MDTOC -->

### 多任务
1.多任务可以划分为两类
* 非抢占式多任务，进程自己主动让出，如果不让出就麻烦
* 抢占式多任务，由调度程序挂起进程，Linux使用抢占式多任务

2.IO消耗性/CPU消耗性
* IO消耗型，比如GUI界面
* CPU消耗型，比如无限循环执行
* IO和CPU都消耗型，比如X Window服务

3.为了提高响应优化，Linux一般会优先调度IO消耗性进程

4.实时进程和普通进程
* 实时进程一直运行直到退出，除非它阻塞才会释放CPU
* 实时进程只能被更高优先级的实时进程抢占
* 实时进程优先级高于普通进程
* 如果有多个实时进程，就会根据实时进程调度策略来进行调度

5.Linux采用两种不同的优先级范围
* nice值，越大优先级越低，用于普通进程，超级用户可以设置为复制
* 实时优先级，用于实时进程，首先要知道，实时进程优先级高于普通进程，所以它和NICE值不相交

6.时间片，通常很短，代表进程运行完一个时间片就被抢占，交替运行，时间片太长会使系统交互能力欠佳

7.Linux调度类分为采用 CFS 调度算法的默认调度类和实时调度类★

8.Linux的调度入口是schedule，它会找到一个优先级最高的调度类，然后拿到下一个要运行的进程

9.被阻塞的进程处于一个特殊的不可执行状态，比如等待IO，阻塞进程分为可中断和不可中断，但它们都位于同一个等待队列，进程在加入到等待队列的同时向内核注册了一个回调函数，告诉内核我在等待的数据，如果数据到了就唤醒我

### 针对普通进程的-完全公平调度算法CFS
CFS出发点在于，每个进程的运行时间和权重(和NICE值相关)几何加权之后的虚拟时间能够完全公平，当然这是理想情况下

CFS完全公平调度算法引入了虚拟实时的概念:
* 如果一个默认优先级的任务运行 200ms，则它的虚拟运行时间也为 200ms
* 如果一个较低优先级的任务运行 200ms，则它的虚拟运行时间将大于 200ms

一个IO任务，虚拟运行时间一般都很小，那么Linux会优先运行IO进程

CFS核心是选择具有最小虚拟运行时间的任务，在这里，CFS采用了红黑树的方式，红黑树存储了系统所有的可运行进程，虚拟时间最小的就对应在树中最左侧的叶子节点

### 抢占
一个任务可以在某些时刻抢占了正在CPU上运行任务的CPU执行权限。根据抢占时机又可以分为用户空间抢占和内核抢占

#### 用户抢占
内核在即将返回用户空间时检查进程是否需要重新调度，如果设置了need_resched，就会发生调度, 这被称为用户抢占

用户抢占发生的时机:
* 从系统调用返回用户空间
* 从中断（异常）处理程序返回用户空间

#### 内核抢占
Linux支持内核抢占，是指一个在内核态运行的进程，可能在执行内核函数期间被另一个进程取代，前提是重新调度室安全的，也就是没有持有锁，从中断返回内核空间的时候，内核会检查need_resched和preempt_count(代表是否持有锁)，如果need_resched被设置切没有持有锁，那么就会执行调度程序

### 实时进程的调度策略
Linux提供两种实时调度策略，它们并不被CFS调度器来管理，而是被一个实时调度器管理:
* SCHED_FIFO
   * 先入先出
   * 一旦执行，除非受阻塞或显示释放处理器，否则只有更高优先级的FIFO或者RR任务可以抢占，高优先级总是立即抢占低优先级

* SCHED_RR
   * 有时间片的概念，耗尽之后就不能再执行了
   * 耗尽之后，同一优先级其他实时进程被轮流调度，注意是同一优先级

实时优先级范围是从0到99，NICE的-20到19正好对应100到139

### 与优先级相关的系统调用
在Linux中，可以使用sched_setaffinity来保证进程运行在同一个处理器，同时，Linux通过一种软强制的的方式，尽量来保证运行在同一个核上
