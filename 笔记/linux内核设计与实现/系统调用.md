<!-- MDTOC maxdepth:6 firsth1:2 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

   - [系统调用](#系统调用)   
   - [系统调用处理程序](#系统调用处理程序)   
   - [系统调用的实现](#系统调用的实现)   

<!-- /MDTOC -->


### 系统调用
1.应用很多时候都会调用到系统调用来完成一些操作，可是系统调用是在内核态下才能调用，用户态下的应用程序是无法直接调用到的

2.系统调用由操作系统内核提供，运行于内核态；而普通的函数调用由函数库或用户自己提供，运行于用户态

3.一般情况下，应用程序通过在用户空间实现的应用编程接口(而不是直接通过系统调用)来编程，通常通过C库中定义的函数调用来进行，我们程序员只需要和C库中的API打交道就可以了，让内核和真正的系统调用打交道

5.例如在用户空间调用open函数，则会在内核空间调用sys_open。一个已经安装的系统的支持的所有的系统调用可以在/usr/include/bits/syscall.h文件里面看到

6.每一种系统调用都有一个一旦指定就不能改变的系统调用号

### 系统调用处理程序
一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作"保护模式"）。系统调用是这些规则的一个例外。其原理是进程先用适当的值(包括系统调用号，调用参数)填充寄存器，然后调用一个特殊的指令，这个指令会跳到一个事先定义的内核中的一个位置（当然，这个位置是用户进程可读但是不可写的）。在Intel CPU中，这个由中断0x80实现。硬件知道一旦你跳到这个位置，你就不是在限制模式下运行的用户，而是作为操作系统的内核--所以你就可以为所欲为。

### 系统调用的实现
1.系统调用必须确保参数合法有效，尤其是指针，防止进程给内核一个它并没有访问权限的指针
2.当编写完一个系统调用，我们需要将它注册成真正的系统调用
* 在系统调用表中加上一个表项
* 编译进内核映像
3.通过Linux的_syscall来进行系统调用
