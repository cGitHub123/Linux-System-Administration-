### 领导者与追随者

三种流行的复制算法:
* 单领导者
* 多领导者
* 无领导者

数据库的写入操作，需要传播到所有副本上，最常见的是基于领导者的复制，数据写入请求先发给领导者，
领导者再将他们发送给追随者，只有领导者可写

不仅仅数据库，很多高可用的消息队列也是这样，比如kafka

数据同步又分为同步和异步，也不一定所有节点都需要确认才算完成，现在很多都是NWR机制，只要大部分节点
确认即可，如果需要所有从库都确认可用性就太差了

一般情况下，基于领导者的复制都是完全异步的，这样即使从库落后了很多，主库也能继续写

#### 扩容

当集群扩容时，我们需要增加副本的时候，如何保证不断变化的数据的正确性呢，停止数据库写入肯定不行，

* 首先，获得主库的一致性快照
* 将快照复制到新节点
* 从库连接主库，拉取快照之后的数据变更

#### 节点宕机

##### 从库挂了

从库上有日志，可以知道故障前的最后一个事务，从库恢复后，从主库拿到所有数据变更即可

##### 主库挂了

主库挂了就比较麻烦，这时候很可能需要人工介入，因为自动切换问题更多,自动切换的步骤如下:
* 确认失效
* 选择一个新主库
* 写入请求到新主库

故障切换会有很多问题:

* 新主库可能没有收到老主库的一些写入操作导致写入丢失
* 可能会出现脑裂问题
* 如果是自动切换，超时时间不好把握

#### 复制日志如何实现

##### 基于语句的复制

就是把SQL语句完全复制到从库，这里有很多问题:

* 比如调用一个now(),每个机器都不一致
* 语句依赖现有数据，比如update XXX where XXX,在每个机器上必须顺序完全一致
* 一些触发器啥的会有副作用

##### WAL预写日志

日志，是一个仅支持追加的字节序列，主库可以将它通过网络发送给从库，它的问题在于如果数据库版本升级
并发生存储格式变化就不太好整了

##### 基于行的逻辑日志复制(CDC的思想之一)

为了解决预写日志的问题，同步发送的不再是一个字节序列，而是一个逻辑日志，比如mysql使用这种方式


##### 基于触发器

基于触发器的是在应用层解决问题，不过这种开销太大，但是比较简单灵活


### 复制延迟问题

如果主库和从库之间采用异步复制，就会有复制延迟的问题，如果客户端读从库，可能和主库的不太一致，解决这个
问题的大方向有三个

#### 读己之写

用户重新加载页面，他们总会看到他们自己提交的任何更新，可以有多种办法:

* 如果内容只有本人能编辑，比如用户资料，那么可以强制读主
* 可以在1分钟之内对相同内容强制读主
* 客户端写入的时候留个时间戳，然后请求从库的时候保证从库已经有这个戳了,使用这种方式还有一些问题，
比如用户多终端

#### 单调读

用户读两次，读了两个从库，一个看到小菜发的帖子，另外一次读因为延迟问题没有看到

单调读，就是一个介于强一致性和最终一致性的方案，根据用户ID选择固定的从库，从库挂了路由到别的从库

#### 一致前缀读

小明: 1+1=?
小红: 2

上面是实际的顺序，然而小菜看到的是下面

小红: 2
小明: 1+1=?

如果以相同的顺序应用写入，许多分布式数据库中，不同的分区独立运行，因此不存在全局写入顺序：当用户
从数据库中读取数据时，可能会看到数据库的某些部分处于较旧的状态，而某些处于较新的状态。

​一种解决方案是，确保任何因果相关的写入都写入相同的分区。对于某些无法高效完成这种操作的应用，
还有一些显式跟踪因果依赖关系的算法

### 多主复制
