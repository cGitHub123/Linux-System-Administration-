### 领导者与追随者

三种流行的复制算法:
* 单领导者
* 多领导者
* 无领导者

数据库的写入操作，需要传播到所有副本上，最常见的是基于领导者的复制，数据写入请求先发给领导者，
领导者再将他们发送给追随者，只有领导者可写

不仅仅数据库，很多高可用的消息队列也是这样，比如kafka

数据同步又分为同步和异步，也不一定所有节点都需要确认才算完成，现在很多都是NWR机制，只要大部分节点
确认即可，如果需要所有从库都确认可用性就太差了

一般情况下，基于领导者的复制都是完全异步的，这样即使从库落后了很多，主库也能继续写

#### 扩容

当集群扩容时，我们需要增加副本的时候，如何保证不断变化的数据的正确性呢，停止数据库写入肯定不行，

* 首先，获得主库的一致性快照
* 将快照复制到新节点
* 从库连接主库，拉取快照之后的数据变更

#### 节点宕机

##### 从库挂了

从库上有日志，可以知道故障前的最后一个事务，从库恢复后，从主库拿到所有数据变更即可

##### 主库挂了

主库挂了就比较麻烦，这时候很可能需要人工介入，因为自动切换问题更多,自动切换的步骤如下:
* 确认失效
* 选择一个新主库
* 写入请求到新主库

故障切换会有很多问题:

* 新主库可能没有收到老主库的一些写入操作导致写入丢失
* 可能会出现脑裂问题
* 如果是自动切换，超时时间不好把握

#### 复制日志如何实现

##### 基于语句的复制

就是把SQL语句完全复制到从库，这里有很多问题:

* 比如调用一个now(),每个机器都不一致
* 语句依赖现有数据，比如update XXX where XXX,在每个机器上必须顺序完全一致
* 一些触发器啥的会有副作用

##### WAL预写日志

日志，是一个仅支持追加的字节序列，主库可以将它通过网络发送给从库，它的问题在于如果数据库版本升级
并发生存储格式变化就不太好整了

##### 基于行的逻辑日志复制(CDC的思想之一)

为了解决预写日志的问题，同步发送的不再是一个字节序列，而是一个逻辑日志，比如mysql使用这种方式


##### 基于触发器

基于触发器的是在应用层解决问题，不过这种开销太大，但是比较简单灵活


### 复制延迟问题



### 多主复制
